# 상속 다루기

[메서드 올리기](#id-section1)<br>


- 상속은 객체 지향 프로그래밍에서 가장 유명한 특성
- 아주 유용한 동시에 오용하기 쉽다.
- 관련 리팩터링
	- [x] 메서드 올리기
	- [x] 필드 올리기
	- [x] 생성자 본문 올리기
	- [x] 메서드 내리기
	- [x] 필드 내리기
- 계층 사이에 클래스를 추가하거나 제거하는 리팩터링
	- [x] 슈퍼클래스 추출하기
	- [x] 서브클래스 제거하기
	- [x] 계층 합치기
	- [x] 필드 값에 따라 동작이 달라지는 코드 
		- 타입 코드를 서브클래스로 바꾸기
- 상속을 잘못된 곳에서 사용하거나 혹은 환경이 변해 문제가 생겼을 때
	- [x] 서브클래스를 위임으로 바꾸기
	- [x] 슈퍼클래스를 위임으로 바꾸기
	- [x] 상속을 위임으로 바꾸는 것이 핵심


<br>
<div id='id-section1'/>

## 12.1 메서드 올리기 Pull Up Method

```kotlin
   class Employee{...}

   class Salesperson : Employee {
      val name() {...}
   }

   class Engineer : Employee {
      val name() {...}
   }
```
**🔻 메서드 올리기**

```kotlin
   class Employee{
      val name() {...}
   }

   class Salesperson : Employee {...}

   class Engineer : Employee {...}
```

### 🔍 메서드 올리기
- 적용하기 가장 쉬운 상황은 메서드들의 본문 코드가 똑같을 때다.
- 테스트에 의존성이 크다 -> 차이점을 찾는 방법이 효과고 좋음
- 서로 다른 두 클래스의 두 메서드를 각각 매개변수화하면 긍정적으로 같은 메서드가 되기도 함.
- 이런 경우 가장 적은 단계를 거쳐 리팩터링하면 각각의 함수를 매개변수화한 다음 메서드를 상속 계층의 위로 올리면 된다.
- 반면 이상하고 복잡한 상황
	- [x] 해당 메서드의 본문에서 참조하는 필드들이 서브클래스에만 있는 경우.
	- [x] 이런 경우 필드들 먼저 슈퍼클래스로 올린 후에 메서드를 올리자.
- 두 메서드의 전체 흐름은 비슷하지만 -> 세부 내용이 다르다면 템플릿 메서드 만들기 고려


### 📍 절차
&emsp;⓵ 똑같이 동작하는 메서드인지 면멸히 살핀다.
> -> 이 핸들러는 처음에는 모든 예외를 다시 던게 해둔다.
> -> 적절한 처리를 해주는 핸들러가 이미 있다면 지금의 콜스택도 처리할 수 있도록 확장한다.

&emsp;⓶ 테스트한다.<br>
&emsp;⓷ 해당 오류 코드를 대체할 예외와 그 밖에 예외를 구분할 식별 방법을 찾는다.<br>
> -> 사용하는 프로그밍 언어에 맞게 선택하면 된다. 대부분 언어에서는 서브클래스를 사용하면 됨.

&emsp;⓸ 정적 검사를 수행한다.<br>
&emsp;⓹ catch절을 수정하여 직접 처리할 수 있는 예외는 적절히 대처하고 그렇지 않은 예외는 다시 던진다.<br>
&emsp;⓺ 테스트한다. <br>
&emsp;⓻ 오류 코드를 반환하는 곳 모두에서 예외를 던지도록 수정한다. 하나씩 수정할 때마다 테스트한다.<br>
&emsp;⓼모두 수정 했다면 그 오류 코드를 콜스택 위로 전달하는 코드를 모두 제거한다. 하나씩 수정할 때마다 테스트한다.<br>
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTEzMzIzMjk2MTAsMjAxNjkwMTkxMSwxNz
g0ODAwMjI2LC05MjMwMTkzMjYsNjU3MjQ5MDk5LDI2ODc5OTYw
M119
-->