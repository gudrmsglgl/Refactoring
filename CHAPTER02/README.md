# 리팩터링 원칙
[리택터링 정의](#2.1) <br>
[두 개의 모자](#2.2-두-개의-모자) <br>
[리팩터링하는 이유](#2.3-리팩터링하는-이유) <br>
[언제 리팩터링해야 할까](#2.4)
<br><br>
## 2.1 리팩터링 정의 <a name="2.1"></a>
> **리택터링**: [명사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 <u>**이해하고 수정하기 쉽도록**</u> <br> 내부 구조를 변경하는 기법

> **리택터링**: [동사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, <u>**여러 가지 리팩터링 기법을 적용**</u>해서 <br>소프트웨어를 재구성하다.

### **리택터링**
    * 동작을 보존하는 작은 단계들을 거쳐 코드를 수정하고 단계들을 순차적으로 연결하여 큰 변화를 만들어 내는 일.
    * 리택터링하는 동안에는 코드가 항상 정상 작동하기 때문에 전체 작업이 끝나지 않더라도 언제든 멈출 수 있다.
    * 잘게 나눔으로써 작업을 더 빨리 처리할 수 있고, 디버깅 시간 축소 
    * 리팩터링의 목적은 코드를 이해하고 수정하기 쉽게 만드는 것
<br>

## 2.2 두 개의 모자
### :guardsman: 기능 추가, 리택터링
:on: 기능추가

    기존 코드는 건드리지 않고 새 기능을 추가하기만 한다.

:on: 리택터링

    기능 추가는 절대 하지 않기로 다짐한 뒤 오로지 코드 재구성에만 전념한다.

> _Tip_. 개발 시 기능추가를 하고 코드를 보며 구조 개선이 필요하다고 생각되면 모자를 바꿔 리택터링 후<br> 코드 구조가 어느 정도 개선되면 다시 모자를 바꿔 기능 추가를 이어간다.  

<br>

## 2.3 리팩터링하는 이유
### :one: **리팩터링하면 소프트웨어 설계가 좋아진다**
    중복 코드 제거
    * 설계 개선 작업의 중요한 한 축을 차지    
    * 모든 코드가 언제나 고유한 일을 수행함을 보장
### :two: **리팩터링하면 소프트웨어를 이해하기 쉬워진다**
    코드의 목적이 더 잘 드러나게, 의도를 명확하게 전달하도록 개선할 수 있다.

### :three: **리택터링하면 버그를 쉽게 찾을 수 있다**
### :four: **리팩터링하면 프로그래밍 속도를 높일 수 있다**
    * 리팩터링하면 코드 개발 속도를 높일 수 있다.
    * 코드가 명확하면 버그를 만들 가능성도 줄고 버그를 만들더라도 디버깅하기 훨씬 쉽다.
    * 지구력 가설
      :내부 설계에 심혈을 기울이면 소프트웨어의 지구력이 높아져서 빠르게 개발할 수 있는 상태를 더 오래 지속할 수 있다

<br>
<div id='id-section1'/>
```
## 2.4 언제 리팩터링해야 할까? <a name="2.4"></a>
> **3의 법칙**
<br>1. 그냥한다
<br>2. 비슷한 일을 두 번째로 하게 되면 일단 진행한다
<br>3. 비슷한 일을 세 번째 하게 되면 리팩터링한
### **준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기**
    ex) 함수 매개변수화하기
### **이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기**
> Ralph johnson: 초기 단계의 리팩터링을 밖을 잘 내다보기 위한 창문 닦기 

    * 조건부 로직 구조 이상하지 않은지
    * 함수 이름을 잘못 정해서 파악하는 데 오래 걸리지는 않는지
    * 어떤 역할을 하는지 이해된 변수는 적절한 이름으로 바꿔주고
    * 긴 함수를 잘게 나누기

### **쓰레기 줍기 리팩터링**

> 간단히 수정할 수 있는 것은 즉시 고치고, 
> 시간이 좀 걸리는 일은 짧은 메모만 남긴 다음, 하던 일을 끝내고 처리 

    * 로직이 쓸데없이 복잡
    * 거의 똑같은 함수 여러 개로 작성 -> 매개변수화한 함수


### **계획된 리팩터링과 수시로 하는 리팩터링**

> 보기 싫은 코드 -> 리팩토링
> But! 잘 작성된 코드 -> 수많은 리팩터링

> " 무언가를 수정하려 할 때는 먼저 수정하기 쉽게 정돈하고
> 그런 다음 쉽게 수정하자 " _켄트 백

> 뛰어난 개발자는  
> 새 기능을 추가하기 쉽도록 코드를 '수정' 하는 것이  
> 그 기능을 가장 빠르게 추가하는 길일 수 있음 안다.

### **오래 걸리는 리팩터링**
> 주어진 문제를 몇 주에 걸쳐 조금씩 해결하는 편이 효과적 

### **코드 리뷰에 리팩터링 활용하기**
> 작성자와 나란히 앉아서 코드를 훑어가면서 리팩터링 하는 것
> -> pair programming

### **리팩터링하지 말아야 할 때**
    * 지저분한 코드를 발견해도 굳이 수정할 필요가 없을 때
    * 외부 API 다루듯 호출해서 쓰는 코드
    * 처음부터 새로 작성하는 게 쉬울 때 
<br>

## 2.5 리팩터링 시 고려할 문제
### :shipit: **새 기능 개발 속도 저하**
> 리팩터링의 궁극적인 목적은 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출한는 것이다.

>건강한 코드의 위력을 충분히 경험해보지 않고서는<br>
코드베이스가 건강할 때와 허약할 때의 생산성 차이를 체감하기 어렵다.

> 생각의 오류<br>
'클린코드' 나  '바람직한 엔지니어링 습관' 처럼 도덕적인 이유로 정당화하는 것.<br>
:no_good: 코드 베이스를 예쁘게 꾸미는 데 있지 않다.<br>
:ok_woman: 오로지 경제적인 이유, 개발 기간을 단축, 기능 추가 시간을 줄이고, 버그 수정 시간을 줄여준다. 

### :shipit: **브랜치**

    * 독립 브랜치로 작업하는 기간이 길어질수록 작업 결과를 마스터로 통합하기가 어려워진다.
    * 머지가 복잡해지는 문제는 기능별 브랜치들이 독립적으로 개발되는 기간이 길어질수록 기하급수적으로 늘어난다.
    

  

##### :ok_woman: &nbsp;**브랜치 관리**

	기능별 브랜치의 통합 주기를 2~3일 단위로 짧게 관리 혹은 더 짧게 (CI, TBD)
    마스터를 건강하게 유지하고, 
    거대한 기능을 잘게 쪼개는 법을 배우고, 
    각 기능을 끌 수 있는 기능 토글(feature flag)을 적용하여 
    -> 완료되지 않은 기능이 시스템 전체를 망치지 않도록 해야 한다.

#####  :question: &nbsp;**기능별 브랜치 사용**  

    브랜치를 자주 통합할 수 있다면 문제가 발생할 가능성을 크게 줄일 수 있다.
    CI를 적용하는 이들도 기능별 브랜치를 많이 사용(단, 마스터와 통합하는 작업 매일)
    
### :shipit: **테스팅**

#####  :white_check_mark: &nbsp;자가 테스트 코드

    * 리팩터링 효과적
    * 새 기능 추가도 훨씬 안전하게 진행 → 실수로 만든 버그를 빠르게 제거
    * 테스트가 실패한다면 가장 최근에 통과한 버전에서 무엇이 달라졌는지 살펴볼 수 있음
    * 리택터링 과정에서 버그 생길 위험이 크다는 불안감 해소

<!--stackedit_data:
eyJoaXN0b3J5IjpbLTEzODQxNDQ1NiwtMTU4MDU5ODcwNiwxOD
E3MTU5OCwxMDExNDE2MjI3LC0yMzA4NDQ2MjQsLTUzMDkyMjI3
NiwtMTM5Mjg4OTk2OCwtMzYwODU0ODYsLTExMzk3NzgyNjUsLT
ExNTcxMDM3NzBdfQ==
-->