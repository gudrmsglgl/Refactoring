# 코드에서 나는 악취
[기이한 이름](#id-section1)<br>
[중복 코드](#id-section2)<br>
[긴 함수](#id-section3)<br>
[긴 매개변수 목록](#id-section4)<br>
[전역 데이터](#id-section5)<br>
[가변 데이터](#id-section6)<br>
[뒤엉킨 변경](#id-section7)<br>


<div id='id-section1'/>

## 3.1 기이한 이름 Mysterious Name
> 코드를 명료하게 표현하는 데 가장 중요한 요소 하나는 '이름'
<br>함수, 모듈, 변수, 클래스 등은 그 이름만 보고 각각이 무슨 일을 하고 어떻게 사용해야 하는지 명확히 알 수 있도록 신경 써서 이름을 지어야 한다.

<br>
<div id='id-section2'/>

## 3.2 중복 코드 Duplicated Code

### 중복 코드의 예

    * 한 클래스에 딸린 두 메서드가 똑같은 표현식을 사용하는 경우
    -> 함수 추출하기 
    
    * 코드가 비슷하긴 한데 완전히 똑같지 않다면
    -> 문장 슬라이드하기로 비슷한 부분을 한곳에 모아 함수 추출하기를 더 쉽게 적용할 수 있는지 살펴본다. 

    * 같은 부모로부터 파생된 서브 클래스들에 코드가 중복
    -> 각자 따로 호출되지 않도록 메서드 올리기 적용해 부모로 옮긴다.


<br>
<div id='id-section3'/>

## 3.3 긴 함수 Long Function
> 코드를 이해하고, 공유하고, 선택하기 쉬워진다는 장점은 함수를 짧게 구성할 때 나오는 것.

### :black_nib: 짧은 함수 
##### :pushpin:&nbsp;&nbsp;좋은 이름

    * 함수를 쪼개야 한다.
    * 주석을 달아야 할 만한 부분은 무조건 함수로 만든다.
    * 그 함수 본문에는 원래 주석으로 설명하려던 코드가 담기고
    * 함수 이름은 동작 방식이 아닌 '의도(intension)' 드러나게 짓는다.
    * 원래 코드보다 길어지더라도 함수로 뽑는다.
    * 단, 함수 이름에 코드의 목적을 드러내야 한다. 
    * 핵심은 함수의 길이가 아닌, 함수의 목적(의도)과 구현 코드의 괴리가 얼마나 큰가.
    * 즉, '무엇을 하는지'를 코드가 잘 설명해주지 못할수록 함수로 만드는게 유리.
##### :pushpin:&nbsp;&nbsp;함수 추출하기
>함수 본문에서 따로 묶어 배내면 좋은 코드 덩어리를 찾아 새로운 함수로 만드는 것.

##### ⚠️&nbsp;&nbsp;~~매개변수와 임시 변수를 많이 사용~~한다면 **추출 작업에 방해**가 된다. 
    🙆‍♀️ 임시 변수를 ➰ 질의 함수로
    🙆‍♀️ 매개변수의 수 ➰ 매개변수 객체 만들기, 객체 통쟤로 넘기기로 줄임.
    🙆‍♀️ 이렇게 적용해도 여전히 임시 변수와 매개변수가 너무 많다면 ➰ 함수를 명령으로 바꾸기
##### :mag_right:&nbsp;&nbsp;&nbsp;추출할 코드 덩어리 찾는 방법

    💡 주석을 참고
      - 주석이 설명하는 코드와 함계 함수로 빼내고, 함수 이름은 주석 내용을 토대로 짓는다.
      - 코드가 단 한줄이라도 따로 설명할 필요가 있다면 함수로 추출하는게 좋다.
    
    💡 조건문 반복문 
      - 조건문 분해하기로 대응
      - 거대한 switch문을 구성하는 case문마다 함수 추출하기를 적용, 각 case의 본문을 함수 호출문 하나로 바꾼다.
      - 같은 조건을 기준으로 나뉘는 switch문이 여러 개
        -> 조건문을 다형성으로 바꾸기 적용
	  - 반복문도 그 안의 코드와 함께 추출해서 독립된 함수로 만든다.
	  - 추출한 반복문 코드에 적합한 이름이 떠오르지 않는다면 다른 두 가지 작업이 섞여 있기 때문 
	    -> 과감히 반복문 쪼개기를 적용해서 작업을 분리

<br>
<div id='id-section4'/>

## 3.4 긴 매개변수 목록 Long Parameter List

> 함수에 필요한 것들을 모조기 매개변수로 전달 
> -> 전역 데이터가 늘어나는 사태를 막을 수 있기 때문에 예전에는 합리적인 방식.<br>
> 하지만 **매개변수 목록이 길어지면 그 자체로 이해하기 어려울 때가 많았다.** 

### :cyclone: 긴 매개변수 처리

    ⚠️ 다른 매개변수에서 값을 얻어올 수 있는 매개변수 
    ↪️ 매개변수를 질의 함수로 바꾸기
    
    ⚠️ 사용 중인 데이터 구조에서 값들을 뽑아 각각을 별개의 매개변수로 전달하는 코드
    ↪️ 객체 통쨰로 넘기기 적용해서 원본 데이터 구조를 그대로 전달
    
    ⚠️ 항상 함께 전달되는 매개변수
    ↪️ 매개변수 객체 만들기로 하나로 묶기

    ⚠️ 함수 동작 방식을 정하는 플래그 역할의 매개변수
    ↪️ 플래그 인수 제거하기로 없애기

    ⚠️ 항상 함께 전달되는 매개변수
    ↪️ 매개변수 객체 만들기로 하나로 묶기
    
    ⚠️ 여러 개의 함수가 특정 매개변수들의 값을 공통으로 사용할 때 
    ↪️ 여러 함수를 클래스로 묶기를 이용하여 공통 값들을 클래스의 필드로 정의

<br>
<div id='id-section5'/>

## 3.5 전역 데이터 Global Data
> 전역 데이터를 주의해야 한다는 말은 개발 초창기부터 들었던 말.
> "우리가 겪을 수 있는 악취 중 가장 지독한 축에 속함"<br>
> "**전역 데이터가 아주 조금만 있더라도 <u>캡슐화하는 것</u>이  <br>
> 소프트웨어가 진화하는 데 따른 변화에 대처할 수 있다.**"

#### ⚠️ 전역 변수의 문제점
	😨 전역 데이터는 코드베이스 어디에서든 건드릴 수 있고 값을 누가 바꿨는지 찾아낼 메커니즘이 없다는게 문제.
	😨 전역 데이터의 대표적인 형태는 전역 변수지만 클래스 변수와 싱글톤에서도 같은 문제가 발생한다.

#### 💊 전역 변수 방지

    🙆‍♀️ 변수 캡슐화
    * 다른 코드에서 오염시킬 가능성이 있는 데이터를 발견할 때마다 이 기법을 적용
    * 이런 데이터를 함수로 감싸는 것만으로도 데이터를 수정하는 부분을 쉽게 찾을 수 있고 접근을 통제할 수 있게 된다.
    * 접근자 함수들을 클래스나 모듈에 접어넣고 그 안에서만 사용할 수 있도록 접근 범위를 최소로 줄이는 것도 좋다.

#### ⚠️ 전역 데이터가 가변 mutable

    * 다루기 까다롭다.
    * 프로그램이 구동된 후에는 값이 바뀌지 않는다고 보장할 수 있는 전역 데이터는 그나마 안전한 편이다.

<br>
<div id='id-section6'/>

## 3.6 가변 데이터 Mutable Data
	* 코드의 다른 곳에서는 다른 값을 기대한다는 사실을 인식하지 못한 채 수정해버리면 
	프로그램이 오작동한다. 
	* 이 문제가 아주 드문 조건에서만 발생한다면 원인을 알아내기가 매우 어렵다.
	* 데이터는 절대 변하지 않고, 
	  데이터를 변경하려면 반드시 (원래 데이터는 그대로 둔 채) 변경하려는 값에 
	  해당하는 복사본을 만들어서 반환한다는 개념을 기본으로 삼고 있다.

#### 💊 무분별한 데이터 수정에 따른 위험을 줄이는 방법

    💡 변수 캡슐화하기
      - 정해놓은 함수를 거쳐야만 값을 수정할 수 있도록 하면 값이 어떻게 수정되는지 
        감시하거나 코드를 개선하기 쉽다.
	
	💡 변수 쪼개기
	  - 하나의 변수에 용도가 다른 값들을 저장하느라 값을 갱신하는 경우
	  - 독립 변수에 저장하게 하여 값 갱신이 문제를 일으킬 여지를 없앤다.	
    
    💡 문장 슬라이드하기 와 함수 추출하기
      - 무언가를 갱신하는 코드로부터 부작용이 없는 코드를 분리
    
    💡 질의 함수와 변경 함수 분리하기
      - API 를 만들 때
      
    💡 세터 제거하기 
      - 세터를 호출하는 클라이언트를 찾는 것만으로도 변수의 유효범위를 줄이는 데 도움
    
    💡 여러 함수를 클래스로 묶기나 여러 함수를 변수로 묶기
      - 변수를 갱신하는 코드들의 유효범위를 (클래스나 변환transform) 제한한다.
    
    💡 참조를 값으로 바꾸기
	  - 구조체처럼 내부 필드에 데이터를 담고 있는 변수일 때
	  - 내부 필드를 직접 수정하지 말고 구조체를 통째로 교체하는 편이 낫다. 
<br>
<div id='id-section7'/>

## 3.7 뒤엉킨 변경 Divergent Change
> 코드를 수정할 때는 시스템에서 고쳐야 할 딱 한 군데를 찾아서 그 부분만 수정할 수 있기를 바란다. <br>
> 이렇게 할 수 없다면 (서로 밀접한 악취인) **뒤엉킨 변경과 산탄총 수술중 하나가** 풍긴다.

#### ⚠️&nbsp;&nbsp;뒤엉킨 변경

    * 단일 책임 원칙(Single Responsiblity Principle)이 제대로 지켜지지 않을 때 나타남.
    * 즉 하나의 모듈이 서로 다른 이유들로 인해 여러 가지 방식으로 변경되는 일이 많을 때 발생한다.

#### 🙆‍♀️&nbsp;&nbsp;단일 원칙 지키기 예

    * 단계 쪼개기
     - 데이터베이스에서 데이터를 가져와서 금융 상품 로직에서 처리해야 하는 일처럼 순차적으로 실행되는 게 자연스러운 맥락일 때
     - 다음 맥락에 필요한 데이터를 특정한 데이터 구조에 담아 전달하게 하는 식으로 단계를 분리
    
    * 함수 옮기기
      - 전체 처리 과정 곳곳에서 각기 다른 맥락의 함수를 호출하는 빈도가 높다면
      - 각 맥락에 해당하는 적당한 모듈을 만들어서 관련 함수를 모은다. 

<!--stackedit_data:
eyJoaXN0b3J5IjpbLTEwNDk0MDY3NzQsLTUyNDc2Mzc4OCwtNj
UwODY0ODExLDE2Mzg5OTM1NDAsLTM2NTk5OTYwOSwtMTMwMDIx
OTM4Miw4NDg0MDI3MjQsMjk5NjkxODgwLDcyMDU3NDQzNCw4Nj
c3OTE0NjEsOTQ1ODE1MDM4LDE4NjUyNjY5MzIsMjA3Mzc0MzU5
NSwtMjA3NzIzNDAyOSwtMTA5MDE2OTE4OSwtNDY3Mzk3NTA4LD
U3NDI1ODczNCwtMTU3MDM4NjcwMV19
-->